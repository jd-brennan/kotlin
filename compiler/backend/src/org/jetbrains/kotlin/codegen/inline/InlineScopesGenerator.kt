/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.codegen.inline

import org.jetbrains.kotlin.load.java.JvmAbi
import org.jetbrains.org.objectweb.asm.Label
import org.jetbrains.org.objectweb.asm.tree.LabelNode
import org.jetbrains.org.objectweb.asm.tree.LineNumberNode
import org.jetbrains.org.objectweb.asm.tree.LocalVariableNode
import org.jetbrains.org.objectweb.asm.tree.MethodNode

class InlineScopesGenerator {
    var inlinedScopes = 0
    var currentCallSiteLineNumber = 0

    fun addInlineScopesInfo(node: MethodNode) {
        val localVariables = node.localVariables ?: return
        val scopeOffset = inlinedScopes
        val labelToIndex = node.getLabelToIndexMap()

        fun LocalVariableNode.contains(other: LocalVariableNode): Boolean {
            val startIndex = labelToIndex[start.label] ?: return false
            val endIndex = labelToIndex[end.label] ?: return false
            val otherStartIndex = labelToIndex[other.start.label] ?: return false
            val otherEndIndex = labelToIndex[other.end.label] ?: return false
            return startIndex < otherStartIndex && endIndex >= otherEndIndex
        }

        // The scope number 0 belongs to the top frame
        var currentInlineScopeNumber = 0

        // For the old naming scheme, the function removes $iv suffixes
        // and adds the scope info. For the new scheme, the function drops
        // previous scope numbers and adds a new one.
        fun addScopeNumber(variable: LocalVariableNode): String =
            variable.name
                .replace(INLINE_FUN_VAR_SUFFIX, "")
                .dropInlineScopeInfo()
                .addScopeInfo(currentInlineScopeNumber + scopeOffset)

        // Inline function and lambda parameters are introduced before the corresponding inline marker variable,
        // so we need to keep track of them to assign the correct scope number later.
        val variablesWithNotMatchingDepth = mutableListOf<LocalVariableNode>()

        // This list is used to keep track of active inline scopes and to map
        // from a number of $iv suffixes to correct scope number.
        val inlineScopesStack = mutableListOf<Pair<LocalVariableNode, Int>>()
        var seenInlineScopesNumber = 0
        var oldScopeNumberOfCurrentMarkerVariable = -1

        val labelToLineNumber = node.getLabelToLineNumberMap()
        val sortedVariables = localVariables.sortedBy { labelToIndex[it.start.label] }
        for (variable in sortedVariables) {
            while (inlineScopesStack.isNotEmpty() && !inlineScopesStack.last().first.contains(variable)) {
                inlineScopesStack.removeLast()
            }

            if (inlineScopesStack.isNotEmpty()) {
                // Affects names generated by addScopeNumber
                currentInlineScopeNumber = inlineScopesStack.last().second
            }

            val name = variable.name
            val info = name.getInlineScopeInfo()
            val scopeNumber = info?.scopeNumber
            when {
                isFakeLocalVariableForInline(name) -> {
                    seenInlineScopesNumber += 1
                    oldScopeNumberOfCurrentMarkerVariable = scopeNumber ?: -1
                    currentInlineScopeNumber = seenInlineScopesNumber

                    val callSiteLineNumber =
                        if (currentInlineScopeNumber == 1) {
                            currentCallSiteLineNumber
                        } else {
                            info?.callSiteLineNumber ?:
                            // When inlining from the code compiled by the old compiler versions,
                            // the marker variable will not contain the call site line number.
                            // In this case we will take the line number of the variable start offset
                            // as the call site line number.
                            labelToLineNumber[variable.start.label] ?: 0
                        }
                    val newName = addScopeNumber(variable).addScopeInfo(callSiteLineNumber)
                    if (name.startsWith(JvmAbi.LOCAL_VARIABLE_NAME_PREFIX_INLINE_ARGUMENT)) {
                        val surroundingScopeNumber = info?.surroundingScopeNumber
                        val newSurroundingScopeNumber = when {
                            // The first encountered inline scope belongs to the lambda, which means
                            // that its surrounding scope is the function where the lambda is being inlined to.
                            currentInlineScopeNumber == 1 -> 0
                            // Every lambda that is already inlined must have a surrounding scope number.
                            // If it doesn't, then it means that we are inlining the code compiled by
                            // the older versions of the Kotlin compiler, where surrounding scope numbers
                            // haven't been introduced yet.
                            surroundingScopeNumber != null -> surroundingScopeNumber + inlinedScopes + 1
                            // If a lambda doesn't have a surrounding scope number, we will calculate its
                            // depth using the number of the $iv suffixes
                            else -> {
                                val depth = getInlineDepth(name)
                                val scopeNumberOnDepth = inlineScopesStack.getOrNull(depth)?.second ?: continue
                                scopeNumberOnDepth + inlinedScopes
                            }
                        }
                        variable.name = newName.addScopeInfo(newSurroundingScopeNumber)
                    } else {
                        variable.name = newName
                    }

                    inlineScopesStack += Pair(variable, currentInlineScopeNumber)

                    variablesWithNotMatchingDepth.forEach { it.name = addScopeNumber(it) }
                    variablesWithNotMatchingDepth.clear()
                }
                scopeNumber != null -> {
                    if (scopeNumber != oldScopeNumberOfCurrentMarkerVariable) {
                        variablesWithNotMatchingDepth.add(variable)
                    } else {
                        variable.name = addScopeNumber(variable)
                    }
                }
                !name.contains(INLINE_FUN_VAR_SUFFIX) -> {
                    if (inlineScopesStack.size == 0) {
                        variablesWithNotMatchingDepth.add(variable)
                    } else if (inlineScopesStack.size == 1) {
                        variable.name = addScopeNumber(variable)
                    }
                }
                else -> {
                    // Since the node is an inline function, the depth of all variables inside is at least one
                    val depth = getInlineDepth(name) + 1
                    if (depth != inlineScopesStack.size) {
                        variablesWithNotMatchingDepth.add(variable)
                    } else {
                        variable.name = addScopeNumber(variable)
                    }
                }
            }
        }

        inlinedScopes += seenInlineScopesNumber
    }
}

fun updateCallSiteLineNumber(name: String, lineNumberMapping: Map<Int, Int>): String =
    updateCallSiteLineNumber(name) { lineNumberMapping[it] ?: it }

fun updateCallSiteLineNumber(name: String, newLineNumber: Int): String =
    updateCallSiteLineNumber(name) { newLineNumber }

private fun updateCallSiteLineNumber(name: String, calculate: (Int) -> Int): String {
    val (scopeNumber, callSiteLineNumber, surroundingScopeNumber) = name.getInlineScopeInfo() ?: return name
    if (callSiteLineNumber == null) {
        return name
    }

    val newLineNumber = calculate(callSiteLineNumber)
    if (newLineNumber == callSiteLineNumber) {
        return name
    }

    val newName = name
        .dropInlineScopeInfo()
        .addScopeInfo(scopeNumber)
        .addScopeInfo(newLineNumber)

    if (surroundingScopeNumber == null) {
        return newName
    }
    return newName.addScopeInfo(surroundingScopeNumber)
}

internal fun MethodNode.getLabelToIndexMap(): Map<Label, Int> =
    instructions.filterIsInstance<LabelNode>()
        .withIndex()
        .associate { (index, labelNode) ->
            labelNode.label to index
        }

private fun MethodNode.getLabelToLineNumberMap(): Map<Label, Int> {
    val result = mutableMapOf<Label, Int>()
    var currentLineNumber = 0
    for (insn in instructions) {
        if (insn is LineNumberNode) {
            currentLineNumber = insn.line
        } else if (insn is LabelNode) {
            result[insn.label] = currentLineNumber
        }
    }

    return result
}

fun String.addScopeInfo(number: Int): String =
    "$this$INLINE_SCOPE_NUMBER_SEPARATOR$number"

private fun getInlineDepth(variableName: String): Int {
    var endIndex = variableName.length
    var depth = 0

    val suffixLen = INLINE_FUN_VAR_SUFFIX.length
    while (endIndex >= suffixLen) {
        if (variableName.substring(endIndex - suffixLen, endIndex) != INLINE_FUN_VAR_SUFFIX) {
            break
        }

        depth++
        endIndex -= suffixLen
    }

    return depth
}
